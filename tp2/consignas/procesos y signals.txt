
ğŸ’» Ejercicio 1: â€œHola, soy tu hijoâ€

DescripciÃ³n:
El proceso padre crea un hijo y ambos imprimen sus PID.

Pistas:

Usa fork().

En el hijo, imprime su PID y el del padre (getpid(), getppid()).

En el padre, espera al hijo con wait().

=========================================
=========================================

Ejercicio 2: â€œCrea 3 hijos secuencialmenteâ€
DescripciÃ³n:
El proceso padre crea 3 hijos, uno por uno, y espera a que cada uno termine antes de crear el siguiente.

=========================================
=========================================

Ejercicio 3: â€œCrea varios hijos en paraleloâ€
DescripciÃ³n:
El padre crea N hijos (por ejemplo 5), todos se ejecutan al mismo tiempo, y el padre espera a que terminen todos.
Pistas:
Usa un bucle for con fork().
El padre usa un bucle con wait(NULL) para reapearlos.
Los hijos imprimen mensajes diferentes (por ejemplo, â€œSoy el hijo 1â€).

=========================================
=========================================
Ejercicio 4: â€œComunicaciÃ³n con seÃ±alesâ€
DescripciÃ³n:
El padre crea un hijo. Luego le envÃ­a una seÃ±al (SIGUSR1) al hijo, y el hijo reacciona con un handler.
Pistas:
Instalar signal(SIGUSR1, handler) en el hijo.
El padre hace kill(pid_hijo, SIGUSR1).
El handler imprime â€œRecibÃ­ una seÃ±al del padreâ€.

=========================================
=========================================

ğŸ’» Ejercicio 5: â€œTerminar hijo con SIGTERMâ€

DescripciÃ³n:
El padre crea un hijo que entra en un bucle infinito. Luego de 5 segundos, el padre lo termina con SIGTERM.

Pistas:

Usa sleep(5) en el padre.

Usa signal(SIGTERM, handler) en el hijo para despedirse.

El padre hace kill(pid, SIGTERM).

=========================================
=========================================

ğŸ’» Ejercicio 6: â€œEvitar zombiesâ€

DescripciÃ³n:
Crea un hijo que termina solo. El padre no usa wait(), sino un handler de SIGCHLD para limpiar el proceso.

Pistas:

Instalar signal(SIGCHLD, handler).

En el handler, llamar a wait(NULL).

=========================================
=========================================

ğŸ’» Ejercicio 7: â€œMÃºltiples hijos + SIGCHLDâ€

DescripciÃ³n:
El padre crea varios hijos. Cada hijo termina despuÃ©s de un tiempo aleatorio (con sleep(rand()%5)), y el padre los limpia automÃ¡ticamente con el handler.

Pistas:

Usa signal(SIGCHLD, handler).

Dentro del handler, usar while (waitpid(-1, NULL, WNOHANG) > 0); para limpiar varios hijos de una sola vez.

=========================================
=========================================

ğŸ’» Ejercicio 8: â€œEjecutar un comando externoâ€

DescripciÃ³n:
El programa pide al usuario un comando, crea un proceso hijo, y en el hijo ejecuta el comando con execvp().

=========================================
=========================================

ğŸ’» Ejercicio 9: â€œShell con Ctrl+C manejadoâ€

DescripciÃ³n:
Implementar una shell bÃ¡sica donde Ctrl+C (SIGINT) no mata a la shell, pero sÃ­ mata al proceso hijo que se estÃ© ejecutando.

Pistas:

Ignorar SIGINT en el proceso padre (signal(SIGINT, SIG_IGN)).

Restaurar el comportamiento por defecto (SIG_DFL) en el hijo antes de ejecutar execvp().

=========================================
=========================================

ğŸ’» Ejercicio 10: â€œShell con procesos en backgroundâ€

DescripciÃ³n:
Permitir ejecutar comandos con & al final (como sleep 5 &) que no bloqueen la shell.

Pistas:

Si el comando termina con &, no hagas wait() en el padre.

Instalar signal(SIGCHLD, handler) para limpiar los hijos terminados.